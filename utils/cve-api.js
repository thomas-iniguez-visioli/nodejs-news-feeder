import got from 'got'

/**
 * Delays execution for a specified number of milliseconds
 * @param {number} ms - Milliseconds to delay
 * @returns {Promise<void>}
 */
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms))
}

/**
 * Récupère les CVE depuis l'API NVD avec gestion du rate limiting et retry logic
 * @param {Object} options - Options de requête
 * @param {Date} options.pubStartDate - Date de début de publication
 * @param {Date} options.pubEndDate - Date de fin de publication (optionnel)
 * @param {number} options.resultsPerPage - Nombre de résultats par page
 * @param {number} options.startIndex - Index de départ pour la pagination
 * @param {string} options.apiEndpoint - URL de l'API NVD
 * @param {string|null} options.apiKey - Clé API optionnelle
 * @returns {Promise<Object>} - Réponse de l'API contenant les CVE
 */
export async function fetchCVEs(options) {
  const {
    pubStartDate,
    pubEndDate,
    resultsPerPage = 100,
    startIndex = 0,
    apiEndpoint,
    apiKey = null
  } = options

  // Construire les paramètres de requête
  const searchParams = {
    resultsPerPage,
    startIndex
  }

  // Ajouter les filtres de date
  // L'API NVD 2.0 nécessite TOUJOURS pubEndDate si pubStartDate est spécifié
  if (pubStartDate) {
    searchParams.pubStartDate = pubStartDate.toISOString()
    // Si pas de date de fin spécifiée, utiliser une date 120 jours après le début
    // (l'API NVD a une limite de 120 jours par requête)
    let endDate = pubEndDate
    if (!endDate) {
      endDate = new Date(pubStartDate.getTime() + (120 * 24 * 60 * 60 * 1000))
      // S'assurer que la date de fin n'est pas dans le futur
      const now = new Date()
      if (endDate > now) {
        endDate = now
      }
    }
    searchParams.pubEndDate = endDate.toISOString()
  } else if (pubEndDate) {
    searchParams.pubEndDate = pubEndDate.toISOString()
  }

  // Configurer les headers
  const headers = {}
  if (apiKey) {
    headers.apiKey = apiKey
  }

  // Retry logic avec exponential backoff
  const maxRetries = 3
  let lastError

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const response = await got(apiEndpoint, {
        searchParams,
        headers,
        responseType: 'json',
        timeout: {
          request: 30000 // 30 secondes timeout
        }
      })

      // Valider la structure de la réponse
      if (!response.body) {
        throw new Error('Réponse API vide')
      }

      return response.body
    } catch (error) {
      lastError = error
      
      // Si c'est une erreur 429 (rate limit), attendre plus longtemps
      if (error.response?.statusCode === 429) {
        const retryAfter = error.response.headers['retry-after']
        const waitTime = retryAfter ? parseInt(retryAfter) * 1000 : Math.pow(2, attempt) * 1000
        console.warn(`Rate limit atteint (tentative ${attempt + 1}/${maxRetries}), attente de ${waitTime}ms avant nouvelle tentative...`)
        await delay(waitTime)
        continue
      }

      // Si c'est une erreur 403 (Forbidden), cela peut indiquer un problème d'API key
      if (error.response?.statusCode === 403) {
        console.error('Erreur 403 Forbidden - Vérifiez votre clé API NVD')
        throw new Error('Accès refusé par l\'API NVD. Vérifiez votre clé API.')
      }

      // Si c'est une erreur 404, l'endpoint est peut-être incorrect
      if (error.response?.statusCode === 404) {
        console.error('Erreur 404 Not Found - Vérifiez l\'URL de l\'API')
        throw new Error('Endpoint API introuvable. Vérifiez la configuration.')
      }

      // Pour les autres erreurs réseau, utiliser exponential backoff
      if (attempt < maxRetries - 1) {
        const waitTime = Math.pow(2, attempt) * 1000
        console.warn(`Erreur réseau (tentative ${attempt + 1}/${maxRetries}): ${error.message}`)
        console.warn(`Nouvelle tentative dans ${waitTime}ms...`)
        await delay(waitTime)
        continue
      }
      
      // Dernière tentative échouée, logger les détails
      console.error(`Toutes les tentatives ont échoué pour l'appel API`)
      console.error(`Code de statut: ${error.response?.statusCode || 'N/A'}`)
      console.error(`Message: ${error.message}`)
    }
  }

  // Si toutes les tentatives ont échoué, lever l'erreur
  throw new Error(`Échec après ${maxRetries} tentatives: ${lastError.message}`)
}

/**
 * Récupère toutes les CVE avec gestion automatique de la pagination
 * @param {Date} lastCheckTimestamp - Timestamp de la dernière vérification
 * @param {number} maxResults - Nombre maximum de CVE à récupérer
 * @param {string} apiEndpoint - URL de l'API NVD
 * @param {number} resultsPerPage - Nombre de résultats par page
 * @param {string|null} apiKey - Clé API optionnelle
 * @returns {Promise<Array>} - Tableau de toutes les CVE récupérées
 */
export async function fetchAllCVEs(lastCheckTimestamp, maxResults, apiEndpoint, resultsPerPage = 100, apiKey = null) {
  const allCVEs = []
  let startIndex = 0
  let totalResults = 0
  let pageCount = 0
  
  // Convertir le timestamp en Date
  const pubStartDate = new Date(lastCheckTimestamp)
  
  // Déterminer le délai de rate limiting basé sur la présence d'une clé API
  const rateLimitDelay = apiKey ? 600 : 6000 // 0.6s avec clé, 6s sans clé
  
  console.log(`Utilisation de l'API ${apiKey ? 'avec' : 'sans'} clé (délai: ${rateLimitDelay}ms entre requêtes)`)

  do {
    pageCount++
    
    try {
      // Appeler l'API
      const response = await fetchCVEs({
        pubStartDate,
        resultsPerPage,
        startIndex,
        apiEndpoint,
        apiKey
      })

      // Valider la structure de la réponse
      if (!response || typeof response !== 'object') {
        console.error(`Page ${pageCount}: Réponse API invalide`)
        break
      }

      // Extraire les CVE de la réponse
      const cves = response.vulnerabilities || []
      
      if (cves.length === 0 && startIndex === 0) {
        console.log('Aucune CVE trouvée pour la période spécifiée')
        break
      }
      
      allCVEs.push(...cves)

      // Mettre à jour les compteurs
      totalResults = response.totalResults || 0
      startIndex += resultsPerPage

      console.log(`Page ${pageCount}: Récupéré ${allCVEs.length}/${Math.min(totalResults, maxResults)} CVE...`)

      // Vérifier si on a atteint la limite ou s'il n'y a plus de résultats
      if (allCVEs.length >= maxResults || allCVEs.length >= totalResults) {
        break
      }

      // Respecter le rate limiting entre les requêtes
      if (startIndex < totalResults && allCVEs.length < maxResults) {
        await delay(rateLimitDelay)
      }
    } catch (error) {
      console.error(`Erreur lors de la récupération de la page ${pageCount}:`, error.message)
      
      // Si on a déjà récupéré des CVE, continuer avec ce qu'on a
      if (allCVEs.length > 0) {
        console.warn(`Arrêt de la pagination après ${pageCount} pages. ${allCVEs.length} CVE récupérées.`)
        break
      }
      
      // Sinon, propager l'erreur
      throw error
    }
  } while (startIndex < totalResults && allCVEs.length < maxResults)

  console.log(`Pagination terminée: ${pageCount} pages, ${allCVEs.length} CVE au total`)

  // Limiter au nombre maximum demandé
  return allCVEs.slice(0, maxResults)
}

/**
 * Extrait les informations pertinentes d'une CVE brute de l'API NVD
 * @param {Object} cveItem - Item CVE brut de l'API NVD (format: { cve: {...} })
 * @returns {Object|null} - CVE formatée avec les champs nécessaires, ou null si invalide
 */
export function processCVEItem(cveItem) {
  try {
    // Vérifier que l'objet CVE existe
    if (!cveItem || !cveItem.cve) {
      console.warn('CVE item invalide: structure manquante')
      return null
    }

    const cve = cveItem.cve

    // Extraire l'ID (champ obligatoire)
    const id = cve.id
    if (!id) {
      console.warn('CVE sans ID, ignorée')
      return null
    }

    // Extraire la description (champ obligatoire)
    let description = ''
    try {
      if (cve.descriptions && Array.isArray(cve.descriptions)) {
        // Chercher la description en anglais en priorité
        const englishDesc = cve.descriptions.find(d => d.lang === 'en')
        description = englishDesc ? englishDesc.value : (cve.descriptions[0]?.value || '')
      }
      
      if (!description) {
        console.warn(`CVE ${id}: description manquante, utilisation d'une valeur par défaut`)
        description = 'No description available'
      }
    } catch (error) {
      console.warn(`CVE ${id}: erreur lors de l'extraction de la description:`, error.message)
      description = 'No description available'
    }

    // Extraire la date de publication (champ obligatoire)
    const published = cve.published
    if (!published) {
      console.warn(`CVE ${id}: date de publication manquante`)
      return null
    }

    // Valider le format de la date
    try {
      const dateTest = new Date(published)
      if (isNaN(dateTest.getTime())) {
        console.warn(`CVE ${id}: format de date invalide: ${published}`)
        return null
      }
    } catch (error) {
      console.warn(`CVE ${id}: erreur lors de la validation de la date:`, error.message)
      return null
    }

    // Extraire le score CVSS et la sévérité (optionnels)
    let score = null
    let severity = 'UNKNOWN'

    try {
      if (cve.metrics) {
        // Essayer CVSS v3.1 en priorité
        if (cve.metrics.cvssMetricV31 && Array.isArray(cve.metrics.cvssMetricV31) && cve.metrics.cvssMetricV31.length > 0) {
          const cvssData = cve.metrics.cvssMetricV31[0].cvssData
          score = cvssData?.baseScore || null
          severity = cvssData?.baseSeverity || 'UNKNOWN'
        }
        // Sinon essayer CVSS v3.0
        else if (cve.metrics.cvssMetricV30 && Array.isArray(cve.metrics.cvssMetricV30) && cve.metrics.cvssMetricV30.length > 0) {
          const cvssData = cve.metrics.cvssMetricV30[0].cvssData
          score = cvssData?.baseScore || null
          severity = cvssData?.baseSeverity || 'UNKNOWN'
        }
        // Sinon essayer CVSS v2.0
        else if (cve.metrics.cvssMetricV2 && Array.isArray(cve.metrics.cvssMetricV2) && cve.metrics.cvssMetricV2.length > 0) {
          const cvssData = cve.metrics.cvssMetricV2[0].cvssData
          score = cvssData?.baseScore || null
          severity = cvssData?.baseSeverity || 'UNKNOWN'
        }
      }
    } catch (error) {
      console.warn(`CVE ${id}: erreur lors de l'extraction des métriques CVSS:`, error.message)
      // Continuer avec les valeurs par défaut
    }

    // Construire le lien vers la page de détails NVD
    const link = `https://nvd.nist.gov/vuln/detail/${id}`

    return {
      id,
      description,
      published,
      severity,
      score,
      link
    }
  } catch (error) {
    const cveId = cveItem?.cve?.id || 'ID inconnu'
    console.error(`Erreur inattendue lors du traitement de la CVE ${cveId}:`, error.message)
    console.error('Stack trace:', error.stack)
    return null
  }
}

/**
 * Formate une CVE traitée en entrée de flux RSS
 * @param {Object} processedCVE - CVE traitée par processCVEItem
 * @returns {Object} - Objet avec les champs nécessaires pour composeFeedItem
 */
export function formatCVEForFeed(processedCVE) {
  if (!processedCVE) {
    throw new Error('CVE traitée invalide: objet null ou undefined')
  }

  const { id, description, published, severity, score, link } = processedCVE

  // Valider les champs obligatoires
  if (!id) {
    throw new Error('CVE traitée invalide: ID manquant')
  }
  
  if (!description) {
    throw new Error(`CVE ${id}: description manquante`)
  }
  
  if (!published) {
    throw new Error(`CVE ${id}: date de publication manquante`)
  }
  
  if (!link) {
    throw new Error(`CVE ${id}: lien manquant`)
  }

  try {
    // Créer le titre avec l'ID CVE et un résumé court
    // Limiter la description à 100 caractères pour le titre
    const shortDesc = description.length > 100 
      ? description.substring(0, 100) + '...' 
      : description
    const title = `${id}: ${shortDesc}`

    // Créer la description complète avec le score CVSS
    let fullDescription = description
    if (score !== null && score !== undefined) {
      fullDescription += ` | CVSS Score: ${score} (${severity})`
    } else {
      fullDescription += ` | Severity: ${severity}`
    }

    // Convertir la date de publication en format RFC822
    // La date est déjà au format ISO de l'API
    const pubDate = published

    // Le guid est basé sur l'ID CVE (unique)
    const guid = id

    return {
      title,
      description: fullDescription,
      pubDate,
      link,
      guid
    }
  } catch (error) {
    throw new Error(`Erreur lors du formatage de la CVE ${id}: ${error.message}`)
  }
}
